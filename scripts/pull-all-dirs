#!/usr/bin/env bash

# pull-all-dirs - Pull git repositories in all subdirectories that are behind upstream
# Usage: pull-all-dirs [directory]

set -euo pipefail

target_dir="${1:-.}"
concurrency="${PULL_CONCURRENCY:-4}"
concurrency=${concurrency:-4}
(( concurrency < 1 )) && concurrency=1

if [[ ! -d "$target_dir" ]]; then
    echo "Error: Directory '$target_dir' does not exist" >&2
    exit 1
fi

cd "$target_dir"

updated_file="$(mktemp)"
trap 'rm -f "$updated_file"' EXIT

process_repo() {
    local dir=$1

    [[ -d "$dir/.git" ]] || return 0

    if ! git -C "$dir" remote update >/dev/null 2>&1; then
        echo "Warning: Could not update remotes for '$dir'" >&2
        return 0
    fi

    if git -C "$dir" status -uno | grep -q "Your branch is behind"; then
        echo "Pulling updates for: $dir"
        if git -C "$dir" pull --ff-only; then
            printf '%s\n' "$dir" >>"$updated_file"
        else
            echo "Error: Failed to pull updates for '$dir'" >&2
        fi
    fi
}

running_jobs=0

wait_for_slot() {
    while (( running_jobs >= concurrency )); do
        wait -n || true
        ((running_jobs--))
    done
}

for dir in */; do
    [[ -d "$dir" ]] || continue

    wait_for_slot
    process_repo "$dir" &
    ((++running_jobs))
done

while (( running_jobs > 0 )); do
    wait -n || true
    ((running_jobs--))
done

if [[ ! -s "$updated_file" ]]; then
    echo "All repositories are up to date."
    exit 0
fi

mapfile -t updated_repos <"$updated_file"
echo "Updated ${#updated_repos[@]} repository/repositories:"
printf "  - %s\n" "${updated_repos[@]}"
